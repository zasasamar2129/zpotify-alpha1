import os
import asyncio
import aiohttp
import aiofiles
import logging
from typing import Dict, List, Optional
from datetime import datetime
from pathlib import Path
from bs4 import BeautifulSoup
import json
import re
from urllib.parse import urlparse, unquote
from pyrogram import filters, Client
from pyrogram.types import Message
from mbot import Mbot, LOG_GROUP, AUTH_CHATS
from mbot.utils.util import is_maintenance_mode
from mbot.utils.language_utils import get_user_language
from mbot.utils.premium import (
    premium_required,
    cooldown_required,
    daily_limit_required,
    premium
)

from mbot.__init__ import (
    BAN_LIST_FILE, 
    MAINTENANCE_FILE, 
    USER_LIST_FILE, 
    USER_INFO_FILE, 
    USER_LANGUAGES_FILE, 
    PREMIUM_USERS_FILE, 
    PREMIUM_COOLDOWN_FILE, 
    DAILY_LIMITS_FILE)
# Configure logging

# Load banned users from file
def load_banned_users():
    if os.path.exists(BAN_LIST_FILE):
        with open(BAN_LIST_FILE, "r") as f:
            return set(json.load(f))
    return set()
banned_users = load_banned_users()

logger = logging.getLogger(__name__)


# Add these dictionaries to your pinterest.py file, preferably near the other response dictionaries

PINTEREST_RESPONSES = {
    "en": {
        "processing": "ЁЯФД Processing Pinterest link...",
        "processing_board": "ЁЯФД Processing Pinterest board...",
        "download_success": "тЬЕ Successfully downloaded Pinterest content",
        "pin_success": "ЁЯУМ Pinterest pin downloaded successfully",
        "board_success": "ЁЯУМ Successfully downloaded {count} pins from board",
        "error": "тЭМ Error downloading from Pinterest: {error}",
        "invalid_url": "тЪая╕П Invalid Pinterest URL format",
        "no_content": "тЪая╕П No downloadable content found",
        "rate_limit": "тЪая╕П Please wait before downloading more content",
        "maintenance": "ЁЯФз Pinterest downloader is under maintenance",
        "banned": "ЁЯЪл You are banned from using this feature",
        "premium_required": "ЁЯТО Premium feature - upgrade to access",
        "cooldown": "тП│ Please wait {time} before downloading again",
        "daily_limit": "ЁЯУК You've reached your daily download limit",
        "media_caption": "ЁЯУМ {title}\n\n{description}",
        "video_caption": "ЁЯУ╣ {title}\n\n{description}",
        "board_limit": "Showing first {limit} pins from board"
    },
    "fa": {
        "processing": "ЁЯФД ╪п╪▒ ╪н╪з┘Д ┘╛╪▒╪п╪з╪▓╪┤ ┘Д█М┘Ж┌й Pinterest...",
        "processing_board": "ЁЯФД ╪п╪▒ ╪н╪з┘Д ┘╛╪▒╪п╪з╪▓╪┤ ╪к╪о╪к┘З Pinterest...",
        "download_success": "тЬЕ ┘Е╪н╪к┘И╪з█М Pinterest ╪и╪з ┘Е┘И┘Б┘В█М╪к ╪п╪з┘Ж┘Д┘И╪п ╪┤╪п",
        "pin_success": "ЁЯУМ ┘╛█М┘Ж Pinterest ╪и╪з ┘Е┘И┘Б┘В█М╪к ╪п╪з┘Ж┘Д┘И╪п ╪┤╪п",
        "board_success": "ЁЯУМ {count} ┘╛█М┘Ж ╪з╪▓ ╪к╪о╪к┘З ╪и╪з ┘Е┘И┘Б┘В█М╪к ╪п╪з┘Ж┘Д┘И╪п ╪┤╪п",
        "error": "тЭМ ╪о╪╖╪з ╪п╪▒ ╪п╪з┘Ж┘Д┘И╪п ╪з╪▓ Pinterest: {error}",
        "invalid_url": "тЪая╕П ┘Б╪▒┘Е╪к URL ┘Ж╪з╪п╪▒╪│╪к ╪з╪│╪к",
        "no_content": "тЪая╕П ┘Е╪н╪к┘И╪з█М█М ╪и╪▒╪з█М ╪п╪з┘Ж┘Д┘И╪п █М╪з┘Б╪к ┘Ж╪┤╪п",
        "rate_limit": "тЪая╕П ┘Д╪╖┘Б╪з┘Л ┘В╪и┘Д ╪з╪▓ ╪п╪з┘Ж┘Д┘И╪п ╪и█М╪┤╪к╪▒ ╪╡╪и╪▒ ┌й┘Ж█М╪п",
        "maintenance": "ЁЯФз ╪п╪з┘Ж┘Д┘И╪п╪▒ Pinterest ╪п╪▒ ╪н╪з┘Д ╪к╪╣┘Е█М╪▒ ╪з╪│╪к",
        "banned": "ЁЯЪл ╪┤┘Е╪з ╪з╪▓ ╪з╪│╪к┘Б╪з╪п┘З ╪з╪▓ ╪з█М┘Ж ┘И█М┌Ш┌п█М ┘Е╪н╪▒┘И┘Е ┘З╪│╪к█М╪п",
        "premium_required": "ЁЯТО ┘И█М┌Ш┌п█М ┘╛╪▒█М┘Е█М┘И┘Е - ╪и╪▒╪з█М ╪п╪│╪к╪▒╪│█М ╪з╪▒╪к┘В╪з ╪п┘З█М╪п",
        "cooldown": "тП│ ┘Д╪╖┘Б╪з┘Л {time} ┘В╪и┘Д ╪з╪▓ ╪п╪з┘Ж┘Д┘И╪п ┘Е╪м╪п╪п ╪╡╪и╪▒ ┌й┘Ж█М╪п",
        "daily_limit": "ЁЯУК ╪и┘З ╪н╪п ┘Е╪м╪з╪▓ ╪п╪з┘Ж┘Д┘И╪п ╪▒┘И╪▓╪з┘Ж┘З ╪▒╪│█М╪п┘ЗтАМ╪з█М╪п",
        "media_caption": "ЁЯУМ {title}\n\n{description}",
        "video_caption": "ЁЯУ╣ {title}\n\n{description}",
        "board_limit": "┘Ж┘Е╪з█М╪┤ ╪з┘И┘Д█М┘Ж {limit} ┘╛█М┘Ж ╪з╪▓ ╪к╪о╪к┘З"
    },
    "es": {
        "processing": "ЁЯФД Procesando enlace de Pinterest...",
        "processing_board": "ЁЯФД Procesando tablero de Pinterest...",
        "download_success": "тЬЕ Contenido de Pinterest descargado con ├йxito",
        "pin_success": "ЁЯУМ Pin de Pinterest descargado con ├йxito",
        "board_success": "ЁЯУМ {count} pines del tablero descargados con ├йxito",
        "error": "тЭМ Error al descargar de Pinterest: {error}",
        "invalid_url": "тЪая╕П Formato de URL no v├бlido",
        "no_content": "тЪая╕П No se encontr├│ contenido para descargar",
        "rate_limit": "тЪая╕П Por favor espere antes de descargar m├бs contenido",
        "maintenance": "ЁЯФз El descargador de Pinterest est├б en mantenimiento",
        "banned": "ЁЯЪл Tienes prohibido usar esta funci├│n",
        "premium_required": "ЁЯТО Funci├│n premium - actualiza para acceder",
        "cooldown": "тП│ Por favor espera {time} antes de descargar de nuevo",
        "daily_limit": "ЁЯУК Has alcanzado tu l├нmite diario de descargas",
        "media_caption": "ЁЯУМ {title}\n\n{description}",
        "video_caption": "ЁЯУ╣ {title}\n\n{description}",
        "board_limit": "Mostrando los primeros {limit} pines del tablero"
    },
    "ru": {
        "processing": "ЁЯФД ╨Ю╨▒╤А╨░╨▒╨╛╤В╨║╨░ ╤Б╤Б╤Л╨╗╨║╨╕ Pinterest...",
        "processing_board": "ЁЯФД ╨Ю╨▒╤А╨░╨▒╨╛╤В╨║╨░ ╨┤╨╛╤Б╨║╨╕ Pinterest...",
        "download_success": "тЬЕ ╨Ъ╨╛╨╜╤В╨╡╨╜╤В Pinterest ╤Г╤Б╨┐╨╡╤И╨╜╨╛ ╨╖╨░╨│╤А╤Г╨╢╨╡╨╜",
        "pin_success": "ЁЯУМ ╨Я╨╕╨╜ Pinterest ╤Г╤Б╨┐╨╡╤И╨╜╨╛ ╨╖╨░╨│╤А╤Г╨╢╨╡╨╜",
        "board_success": "ЁЯУМ {count} ╨┐╨╕╨╜╨╛╨▓ ╤Б ╨┤╨╛╤Б╨║╨╕ ╤Г╤Б╨┐╨╡╤И╨╜╨╛ ╨╖╨░╨│╤А╤Г╨╢╨╡╨╜╤Л",
        "error": "тЭМ ╨Ю╤И╨╕╨▒╨║╨░ ╨╖╨░╨│╤А╤Г╨╖╨║╨╕ ╨╕╨╖ Pinterest: {error}",
        "invalid_url": "тЪая╕П ╨Э╨╡╨▓╨╡╤А╨╜╤Л╨╣ ╤Д╨╛╤А╨╝╨░╤В URL",
        "no_content": "тЪая╕П ╨Э╨╡ ╨╜╨░╨╣╨┤╨╡╨╜╨╛ ╨║╨╛╨╜╤В╨╡╨╜╤В╨░ ╨┤╨╗╤П ╨╖╨░╨│╤А╤Г╨╖╨║╨╕",
        "rate_limit": "тЪая╕П ╨Я╨╛╨╢╨░╨╗╤Г╨╣╤Б╤В╨░, ╨┐╨╛╨┤╨╛╨╢╨┤╨╕╤В╨╡ ╨┐╨╡╤А╨╡╨┤ ╨╖╨░╨│╤А╤Г╨╖╨║╨╛╨╣ ╨╜╨╛╨▓╨╛╨│╨╛ ╨║╨╛╨╜╤В╨╡╨╜╤В╨░",
        "maintenance": "ЁЯФз ╨Ч╨░╨│╤А╤Г╨╖╤З╨╕╨║ Pinterest ╨╜╨░ ╤В╨╡╤Е╨╜╨╕╤З╨╡╤Б╨║╨╛╨╝ ╨╛╨▒╤Б╨╗╤Г╨╢╨╕╨▓╨░╨╜╨╕╨╕",
        "banned": "ЁЯЪл ╨Т╨░╨╝ ╨╖╨░╨┐╤А╨╡╤Й╨╡╨╜╨╛ ╨╕╤Б╨┐╨╛╨╗╤М╨╖╨╛╨▓╨░╤В╤М ╤Н╤В╤Г ╤Д╤Г╨╜╨║╤Ж╨╕╤О",
        "premium_required": "ЁЯТО ╨Я╤А╨╡╨╝╨╕╤Г╨╝ ╤Д╤Г╨╜╨║╤Ж╨╕╤П - ╨╛╨▒╨╜╨╛╨▓╨╕╤В╨╡╤Б╤М ╨┤╨╗╤П ╨┤╨╛╤Б╤В╤Г╨┐╨░",
        "cooldown": "тП│ ╨Я╨╛╨╢╨░╨╗╤Г╨╣╤Б╤В╨░, ╨┐╨╛╨┤╨╛╨╢╨┤╨╕╤В╨╡ {time} ╨┐╨╡╤А╨╡╨┤ ╨┐╨╛╨▓╤В╨╛╤А╨╜╨╛╨╣ ╨╖╨░╨│╤А╤Г╨╖╨║╨╛╨╣",
        "daily_limit": "ЁЯУК ╨Т╤Л ╨┤╨╛╤Б╤В╨╕╨│╨╗╨╕ ╨┤╨╜╨╡╨▓╨╜╨╛╨│╨╛ ╨╗╨╕╨╝╨╕╤В╨░ ╨╖╨░╨│╤А╤Г╨╖╨╛╨║",
        "media_caption": "ЁЯУМ {title}\n\n{description}",
        "video_caption": "ЁЯУ╣ {title}\n\n{description}",
        "board_limit": "╨Я╨╛╨║╨░╨╖╨░╨╜╤Л ╨┐╨╡╤А╨▓╤Л╨╡ {limit} ╨┐╨╕╨╜╨╛╨▓ ╤Б ╨┤╨╛╤Б╨║╨╕"
    },
    "ar": {
        "processing": "ЁЯФД ╪м╪з╪▒┘К ┘Е╪╣╪з┘Д╪м╪й ╪▒╪з╪и╪╖ Pinterest...",
        "processing_board": "ЁЯФД ╪м╪з╪▒┘К ┘Е╪╣╪з┘Д╪м╪й ┘Д┘И╪н╪й Pinterest...",
        "download_success": "тЬЕ ╪к┘Е ╪к┘Ж╪▓┘К┘Д ┘Е╪н╪к┘И┘Й Pinterest ╪и┘Ж╪м╪з╪н",
        "pin_success": "ЁЯУМ ╪к┘Е ╪к┘Ж╪▓┘К┘Д ╪п╪и┘И╪│ Pinterest ╪и┘Ж╪м╪з╪н",
        "board_success": "ЁЯУМ ╪к┘Е ╪к┘Ж╪▓┘К┘Д {count} ╪п╪и┘И╪│ ┘Е┘Ж ╪з┘Д┘Д┘И╪н╪й ╪и┘Ж╪м╪з╪н",
        "error": "тЭМ ╪о╪╖╪г ┘Б┘К ╪з┘Д╪к┘Ж╪▓┘К┘Д ┘Е┘Ж Pinterest: {error}",
        "invalid_url": "тЪая╕П ╪к┘Ж╪│┘К┘В URL ╪║┘К╪▒ ╪╡╪з┘Д╪н",
        "no_content": "тЪая╕П ┘Д┘Е ┘К╪к┘Е ╪з┘Д╪╣╪л┘И╪▒ ╪╣┘Д┘Й ┘Е╪н╪к┘И┘Й ┘Д┘Д╪к┘Ж╪▓┘К┘Д",
        "rate_limit": "тЪая╕П ┘К╪▒╪м┘Й ╪з┘Д╪з┘Ж╪к╪╕╪з╪▒ ┘В╪и┘Д ╪к┘Ж╪▓┘К┘Д ╪з┘Д┘Е╪▓┘К╪п ┘Е┘Ж ╪з┘Д┘Е╪н╪к┘И┘Й",
        "maintenance": "ЁЯФз ╪г╪п╪з╪й ╪к┘Ж╪▓┘К┘Д Pinterest ┘В┘К╪п ╪з┘Д╪╡┘К╪з┘Ж╪й",
        "banned": "ЁЯЪл ┘Е┘Е┘Ж┘И╪╣ ┘Е┘Ж ╪з╪│╪к╪о╪п╪з┘Е ┘З╪░┘З ╪з┘Д┘Е┘К╪▓╪й",
        "premium_required": "ЁЯТО ┘Е┘К╪▓╪й ┘Е┘Е┘К╪▓╪й - ┘В┘Е ╪и╪з┘Д╪к╪▒┘В┘К╪й ┘Д┘Д┘И╪╡┘И┘Д",
        "cooldown": "тП│ ┘К╪▒╪м┘Й ╪з┘Д╪з┘Ж╪к╪╕╪з╪▒ {time} ┘В╪и┘Д ╪з┘Д╪к┘Ж╪▓┘К┘Д ┘Е╪▒╪й ╪г╪о╪▒┘Й",
        "daily_limit": "ЁЯУК ┘Д┘В╪п ┘И╪╡┘Д╪к ╪е┘Д┘Й ╪н╪п ╪з┘Д╪к┘Ж╪▓┘К┘Д ╪з┘Д┘К┘И┘Е┘К",
        "media_caption": "ЁЯУМ {title}\n\n{description}",
        "video_caption": "ЁЯУ╣ {title}\n\n{description}",
        "board_limit": "╪╣╪▒╪╢ ╪г┘И┘Д {limit} ╪п╪и┘И╪│ ┘Е┘Ж ╪з┘Д┘Д┘И╪н╪й"
    },
    "hi": {
        "processing": "ЁЯФД Pinterest рд▓рд┐рдВрдХ рдкреНрд░реЛрд╕реЗрд╕ рдХрд░ рд░рд╣рд╛ рд╣реВрдБ...",
        "processing_board": "ЁЯФД Pinterest рдмреЛрд░реНрдб рдкреНрд░реЛрд╕реЗрд╕ рдХрд░ рд░рд╣рд╛ рд╣реВрдБ...",
        "download_success": "тЬЕ Pinterest рд╕рд╛рдордЧреНрд░реА рд╕рдлрд▓рддрд╛рдкреВрд░реНрд╡рдХ рдбрд╛рдЙрдирд▓реЛрдб рдХреА рдЧрдИ",
        "pin_success": "ЁЯУМ Pinterest рдкрд┐рди рд╕рдлрд▓рддрд╛рдкреВрд░реНрд╡рдХ рдбрд╛рдЙрдирд▓реЛрдб рдХреА рдЧрдИ",
        "board_success": "ЁЯУМ рдмреЛрд░реНрдб рд╕реЗ {count} рдкрд┐рди рд╕рдлрд▓рддрд╛рдкреВрд░реНрд╡рдХ рдбрд╛рдЙрдирд▓реЛрдб рдХреА рдЧрдИрдВ",
        "error": "тЭМ Pinterest рд╕реЗ рдбрд╛рдЙрдирд▓реЛрдб рдХрд░рдиреЗ рдореЗрдВ рддреНрд░реБрдЯрд┐: {error}",
        "invalid_url": "тЪая╕П рдЕрдорд╛рдиреНрдп URL рдкреНрд░рд╛рд░реВрдк",
        "no_content": "тЪая╕П рдбрд╛рдЙрдирд▓реЛрдб рдХреЗ рд▓рд┐рдП рдХреЛрдИ рд╕рд╛рдордЧреНрд░реА рдирд╣реАрдВ рдорд┐рд▓реА",
        "rate_limit": "тЪая╕П рдХреГрдкрдпрд╛ рдЕрдзрд┐рдХ рд╕рд╛рдордЧреНрд░реА рдбрд╛рдЙрдирд▓реЛрдб рдХрд░рдиреЗ рд╕реЗ рдкрд╣рд▓реЗ рдкреНрд░рддреАрдХреНрд╖рд╛ рдХрд░реЗрдВ",
        "maintenance": "ЁЯФз Pinterest рдбрд╛рдЙрдирд▓реЛрдбрд░ рд░рдЦрд░рдЦрд╛рд╡ рдореЗрдВ рд╣реИ",
        "banned": "ЁЯЪл рдЖрдкрдХреЛ рдЗрд╕ рд╕реБрд╡рд┐рдзрд╛ рдХрд╛ рдЙрдкрдпреЛрдЧ рдХрд░рдиреЗ рд╕реЗ рдкреНрд░рддрд┐рдмрдВрдзрд┐рдд рдХрд┐рдпрд╛ рдЧрдпрд╛ рд╣реИ",
        "premium_required": "ЁЯТО рдкреНрд░реАрдорд┐рдпрдо рд╕реБрд╡рд┐рдзрд╛ - рдкрд╣реБрдВрдЪ рдХреЗ рд▓рд┐рдП рдЕрдкрдЧреНрд░реЗрдб рдХрд░реЗрдВ",
        "cooldown": "тП│ рдХреГрдкрдпрд╛ рдлрд┐рд░ рд╕реЗ рдбрд╛рдЙрдирд▓реЛрдб рдХрд░рдиреЗ рд╕реЗ рдкрд╣рд▓реЗ {time} рдкреНрд░рддреАрдХреНрд╖рд╛ рдХрд░реЗрдВ",
        "daily_limit": "ЁЯУК рдЖрдк рдЕрдкрдиреА рджреИрдирд┐рдХ рдбрд╛рдЙрдирд▓реЛрдб рд╕реАрдорд╛ рддрдХ рдкрд╣реБрдБрдЪ рдЪреБрдХреЗ рд╣реИрдВ",
        "media_caption": "ЁЯУМ {title}\n\n{description}",
        "video_caption": "ЁЯУ╣ {title}\n\n{description}",
        "board_limit": "рдмреЛрд░реНрдб рд╕реЗ рдкрд╣рд▓реЗ {limit} рдкрд┐рди рджрд┐рдЦрд╛ рд░рд╣рд╛ рд╣реВрдБ"
    }
}

PINTEREST_STRINGS = {
    "en": {
        "pin": "ЁЯУМ Pin",
        "board": "ЁЯУЛ Board",
        "image": "ЁЯЦ╝я╕П Image",
        "video": "ЁЯОе Video",
        "from": "From",
        "pinterest": "Pinterest",
        "download": "Download",
        "content": "Content",
        "username": "Username",
        "description": "Description",
        "date": "Date",
        "size": "Size",
        "dimensions": "Dimensions",
        "duration": "Duration",
        "views": "Views",
        "likes": "Likes",
        "comments": "Comments",
        "saves": "Saves",
        "creator": "Creator",
        "link": "Link",
        "quality": "Quality",
        "type": "Type",
        "status": "Status",
        "success": "Success",
        "failed": "Failed",
        "processing": "Processing",
        "available": "Available",
        "unavailable": "Unavailable",
        "premium": "Premium",
        "free": "Free",
        "limit": "Limit",
        "remaining": "Remaining",
        "total": "Total"
    },
    "fa": {
        "pin": "ЁЯУМ ┘╛█М┘Ж",
        "board": "ЁЯУЛ ╪к╪о╪к┘З",
        "image": "ЁЯЦ╝я╕П ╪к╪╡┘И█М╪▒",
        "video": "ЁЯОе ┘И█М╪п█М┘И",
        "from": "╪з╪▓",
        "pinterest": "Pinterest",
        "download": "╪п╪з┘Ж┘Д┘И╪п",
        "content": "┘Е╪н╪к┘И╪з",
        "username": "┘Ж╪з┘Е ┌й╪з╪▒╪и╪▒█М",
        "description": "╪к┘И╪╢█М╪н╪з╪к",
        "date": "╪к╪з╪▒█М╪о",
        "size": "╪з┘Ж╪п╪з╪▓┘З",
        "dimensions": "╪з╪и╪╣╪з╪п",
        "duration": "┘Е╪п╪к ╪▓┘Е╪з┘Ж",
        "views": "╪и╪з╪▓╪п█М╪п┘З╪з",
        "likes": "┘Д╪з█М┌йтАМ┘З╪з",
        "comments": "┘Ж╪╕╪▒╪з╪к",
        "saves": "╪░╪о█М╪▒┘ЗтАМ┘З╪з",
        "creator": "╪│╪з╪▓┘Ж╪п┘З",
        "link": "┘Д█М┘Ж┌й",
        "quality": "┌й█М┘Б█М╪к",
        "type": "┘Ж┘И╪╣",
        "status": "┘И╪╢╪╣█М╪к",
        "success": "┘Е┘И┘Б┘В",
        "failed": "┘Ж╪з┘Е┘И┘Б┘В",
        "processing": "╪п╪▒ ╪н╪з┘Д ┘╛╪▒╪п╪з╪▓╪┤",
        "available": "┘Е┘И╪м┘И╪п",
        "unavailable": "┘Ж╪з┘Е┘И╪м┘И╪п",
        "premium": "┘╛╪▒█М┘Е█М┘И┘Е",
        "free": "╪▒╪з█М┌п╪з┘Ж",
        "limit": "┘Е╪н╪п┘И╪п█М╪к",
        "remaining": "╪и╪з┘В█МтАМ┘Е╪з┘Ж╪п┘З",
        "total": "┘Е╪м┘Е┘И╪╣"
    },
    "es": {
        "pin": "ЁЯУМ Pin",
        "board": "ЁЯУЛ Tablero",
        "image": "ЁЯЦ╝я╕П Imagen",
        "video": "ЁЯОе Video",
        "from": "De",
        "pinterest": "Pinterest",
        "download": "Descargar",
        "content": "Contenido",
        "username": "Nombre de usuario",
        "description": "Descripci├│n",
        "date": "Fecha",
        "size": "Tama├▒o",
        "dimensions": "Dimensiones",
        "duration": "Duraci├│n",
        "views": "Vistas",
        "likes": "Me gusta",
        "comments": "Comentarios",
        "saves": "Guardados",
        "creator": "Creador",
        "link": "Enlace",
        "quality": "Calidad",
        "type": "Tipo",
        "status": "Estado",
        "success": "├Йxito",
        "failed": "Fallido",
        "processing": "Procesando",
        "available": "Disponible",
        "unavailable": "No disponible",
        "premium": "Premium",
        "free": "Gratis",
        "limit": "L├нmite",
        "remaining": "Restante",
        "total": "Total"
    },
    "ru": {
        "pin": "ЁЯУМ ╨Я╨╕╨╜",
        "board": "ЁЯУЛ ╨Ф╨╛╤Б╨║╨░",
        "image": "ЁЯЦ╝я╕П ╨Ш╨╖╨╛╨▒╤А╨░╨╢╨╡╨╜╨╕╨╡",
        "video": "ЁЯОе ╨Т╨╕╨┤╨╡╨╛",
        "from": "╨Ш╨╖",
        "pinterest": "Pinterest",
        "download": "╨б╨║╨░╤З╨░╤В╤М",
        "content": "╨Ъ╨╛╨╜╤В╨╡╨╜╤В",
        "username": "╨Ш╨╝╤П ╨┐╨╛╨╗╤М╨╖╨╛╨▓╨░╤В╨╡╨╗╤П",
        "description": "╨Ю╨┐╨╕╤Б╨░╨╜╨╕╨╡",
        "date": "╨Ф╨░╤В╨░",
        "size": "╨а╨░╨╖╨╝╨╡╤А",
        "dimensions": "╨а╨░╨╖╨╝╨╡╤А╤Л",
        "duration": "╨Я╤А╨╛╨┤╨╛╨╗╨╢╨╕╤В╨╡╨╗╤М╨╜╨╛╤Б╤В╤М",
        "views": "╨Я╤А╨╛╤Б╨╝╨╛╤В╤А╤Л",
        "likes": "╨Ы╨░╨╣╨║╨╕",
        "comments": "╨Ъ╨╛╨╝╨╝╨╡╨╜╤В╨░╤А╨╕╨╕",
        "saves": "╨б╨╛╤Е╤А╨░╨╜╨╡╨╜╨╕╤П",
        "creator": "╨б╨╛╨╖╨┤╨░╤В╨╡╨╗╤М",
        "link": "╨б╤Б╤Л╨╗╨║╨░",
        "quality": "╨Ъ╨░╤З╨╡╤Б╤В╨▓╨╛",
        "type": "╨в╨╕╨┐",
        "status": "╨б╤В╨░╤В╤Г╤Б",
        "success": "╨г╤Б╨┐╨╡╤Е",
        "failed": "╨Э╨╡╤Г╨┤╨░╤З╨░",
        "processing": "╨Ю╨▒╤А╨░╨▒╨╛╤В╨║╨░",
        "available": "╨Ф╨╛╤Б╤В╤Г╨┐╨╜╨╛",
        "unavailable": "╨Э╨╡╨┤╨╛╤Б╤В╤Г╨┐╨╜╨╛",
        "premium": "╨Я╤А╨╡╨╝╨╕╤Г╨╝",
        "free": "╨С╨╡╤Б╨┐╨╗╨░╤В╨╜╨╛",
        "limit": "╨Ы╨╕╨╝╨╕╤В",
        "remaining": "╨Ю╤Б╤В╨░╨╗╨╛╤Б╤М",
        "total": "╨Т╤Б╨╡╨│╨╛"
    },
    "ar": {
        "pin": "ЁЯУМ ╪п╪и┘И╪│",
        "board": "ЁЯУЛ ┘Д┘И╪н╪й",
        "image": "ЁЯЦ╝я╕П ╪╡┘И╪▒╪й",
        "video": "ЁЯОе ┘Б┘К╪п┘К┘И",
        "from": "┘Е┘Ж",
        "pinterest": "Pinterest",
        "download": "╪к┘Ж╪▓┘К┘Д",
        "content": "┘Е╪н╪к┘И┘Й",
        "username": "╪з╪│┘Е ╪з┘Д┘Е╪│╪к╪о╪п┘Е",
        "description": "┘И╪╡┘Б",
        "date": "╪к╪з╪▒┘К╪о",
        "size": "╪н╪м┘Е",
        "dimensions": "╪г╪и╪╣╪з╪п",
        "duration": "┘Е╪п╪й",
        "views": "┘Е╪┤╪з┘З╪п╪з╪к",
        "likes": "╪е╪╣╪м╪з╪и╪з╪к",
        "comments": "╪к╪╣┘Д┘К┘В╪з╪к",
        "saves": "╪н┘Б╪╕",
        "creator": "╪з┘Д┘Е┘Ж╪┤╪ж",
        "link": "╪▒╪з╪и╪╖",
        "quality": "╪м┘И╪п╪й",
        "type": "┘Ж┘И╪╣",
        "status": "╪н╪з┘Д╪й",
        "success": "┘Ж╪м╪з╪н",
        "failed": "┘Б╪┤┘Д",
        "processing": "╪м╪з╪▒┘К ╪з┘Д┘Е╪╣╪з┘Д╪м╪й",
        "available": "┘Е╪к╪з╪н",
        "unavailable": "╪║┘К╪▒ ┘Е╪к╪з╪н",
        "premium": "╪и╪▒┘К┘Е┘К┘И┘Е",
        "free": "┘Е╪м╪з┘Ж┘К",
        "limit": "╪н╪п",
        "remaining": "┘Е╪к╪и┘В┘К",
        "total": "╪з┘Д┘Е╪м┘Е┘И╪╣"
    },
    "hi": {
        "pin": "ЁЯУМ рдкрд┐рди",
        "board": "ЁЯУЛ рдмреЛрд░реНрдб",
        "image": "ЁЯЦ╝я╕П рдЫрд╡рд┐",
        "video": "ЁЯОе рд╡реАрдбрд┐рдпреЛ",
        "from": "рд╕реЗ",
        "pinterest": "Pinterest",
        "download": "рдбрд╛рдЙрдирд▓реЛрдб",
        "content": "рд╕рд╛рдордЧреНрд░реА",
        "username": "рдЙрдкрдпреЛрдЧрдХрд░реНрддрд╛ рдирд╛рдо",
        "description": "рд╡рд┐рд╡рд░рдг",
        "date": "рддрд┐рдерд┐",
        "size": "рдЖрдХрд╛рд░",
        "dimensions": "рдЖрдпрд╛рдо",
        "duration": "рдЕрд╡рдзрд┐",
        "views": "рджреГрд╢реНрдп",
        "likes": "рдкрд╕рдВрдж",
        "comments": "рдЯрд┐рдкреНрдкрдгрд┐рдпрд╛рдБ",
        "saves": "рд╕рд╣реЗрдЬреЗ рдЧрдП",
        "creator": "рдирд┐рд░реНрдорд╛рддрд╛",
        "link": "рд▓рд┐рдВрдХ",
        "quality": "рдЧреБрдгрд╡рддреНрддрд╛",
        "type": "рдкреНрд░рдХрд╛рд░",
        "status": "рд╕реНрдерд┐рддрд┐",
        "success": "рд╕рдлрд▓",
        "failed": "рдЕрд╕рдлрд▓",
        "processing": "рдкреНрд░рд╕рдВрд╕реНрдХрд░рдг",
        "available": "рдЙрдкрд▓рдмреНрдз",
        "unavailable": "рдЕрдиреБрдкрд▓рдмреНрдз",
        "premium": "рдкреНрд░реАрдорд┐рдпрдо",
        "free": "рдореБрдлреНрдд",
        "limit": "рд╕реАрдорд╛",
        "remaining": "рд╢реЗрд╖",
        "total": "рдХреБрд▓"
    }
}

class PinterestDownloader:
    def __init__(self, download_path: str = "downloads/pinterest"):
        self.download_path = Path(download_path)
        self.download_path.mkdir(parents=True, exist_ok=True)
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'DNT': '1',
            'Connection': 'keep-alive',
            'Upgrade-Insecure-Requests': '1'
        }

    def _extract_images_from_json(self, pin_data: Dict) -> List[Dict]:
        """Extract unique image URLs from Pinterest JSON data"""
        images = []
        seen_urls = set()
        
        def add_unique_image(url: str, width: int = None, height: int = None):
            if url and url not in seen_urls:
                seen_urls.add(url)
                images.append({
                    'url': url,
                    'width': width,
                    'height': height
                })

        if 'images' in pin_data:
            size_preference = ['orig', 'x1200', 'x1000', 'x800', 'x600']
            for size in size_preference:
                if size in pin_data['images']:
                    data = pin_data['images'][size]
                    if isinstance(data, dict) and 'url' in data:
                        add_unique_image(
                            data['url'],
                            data.get('width'),
                            data.get('height')
                        )

        story_pin = pin_data.get('story_pin_data', {})
        if story_pin and 'pages' in story_pin:
            for page in story_pin['pages']:
                for block in page.get('blocks', []):
                    if 'image' in block:
                        image_data = block['image']
                        if isinstance(image_data, dict) and 'images' in image_data:
                            images_list = list(image_data['images'].values())
                            images_list.sort(
                                key=lambda x: (x.get('width', 0) * x.get('height', 0)),
                                reverse=True
                            )
                            for img in images_list:
                                if 'url' in img:
                                    add_unique_image(
                                        img['url'],
                                        img.get('width'),
                                        img.get('height')
                                    )
        
        logger.info(f"Extracted {len(images)} images from JSON")
        return images

    def _extract_images_from_html(self, soup: BeautifulSoup) -> List[Dict]:
        """Extract unique and high-quality images from Pinterest HTML"""
        images = []
        seen_urls = set()

        def normalize_url(url: str) -> str:
            return url.split('?')[0]

        def add_unique_image(url: str, width: int = None, height: int = None):
            if not url:
                return
            normalized_url = normalize_url(url)
            if normalized_url in seen_urls:
                return
            if any(x in url.lower() for x in ['/237x/', '/75x/']):
                return
            seen_urls.add(normalized_url)
            images.append({
                'url': normalized_url,
                'width': width,
                'height': height
            })

        carousel_divs = soup.find_all('div', {'data-test-id': re.compile(r'carousel-img-\d+')})
        for carousel in carousel_divs:
            img_tag = carousel.find('img')
            if img_tag:
                src = img_tag.get('src', '')
                srcset = img_tag.get('srcset', '').split(',')
                best_url = src
                for srcset_item in srcset:
                    parts = srcset_item.strip().split()
                    if len(parts) >= 1 and '736x' in parts[0]:
                        best_url = parts[0]
                        break
                if '736x' not in best_url:
                    best_url = re.sub(r'/\d+x/', '/736x/', best_url)
                add_unique_image(best_url)

        quality_indicators = ['/originals/', '/736x/', '/564x/', '/550x/', '/474x/']
        for img in soup.find_all('img', {'src': True}):
            src = img.get('src', '')
            if any(x in src.lower() for x in quality_indicators):
                add_unique_image(src)

        images.sort(
            key=lambda x: (x.get('width', 0) or 0) * (x.get('height', 0) or 0),
            reverse=True
        )
        return images
    
    async def _resolve_short_url(self, url: str) -> str:
        """Resolve pin.it short URL to full Pinterest URL"""
        try:
            async with aiohttp.ClientSession(headers=self.headers) as session:
                async with session.get(url, allow_redirects=True) as response:
                    if response.status == 200:
                        return str(response.url)
            return url
        except Exception as e:
            logger.error(f"Error resolving short URL: {str(e)}")
            return url

    def _normalize_pinterest_url(self, url: str) -> str:
        """Convert any Pinterest URL to standard format"""
        url = url.split('?')[0].rstrip('/')
        parsed = urlparse(url)
        
        if any(domain in parsed.netloc for domain in ['pin.it', 'pinterest.com', 'www.pinterest.com']) or \
           parsed.netloc.endswith('pinterest.com'):
            path = parsed.path.strip('/')
            if 'pin' in path:
                pin_id = re.search(r'pin[/]?([0-9]+)', path)
                if pin_id:
                    return f"https://www.pinterest.com/pin/{pin_id.group(1)}"
            return f"https://www.pinterest.com/{path}"
        return url

    async def _parse_url(self, url: str) -> Dict:
        """Parse Pinterest URL to determine content type"""
        if "pin.it" in url:
            url = await self._resolve_short_url(url)
        
        url = self._normalize_pinterest_url(url)
        
        if "/pin/" in url:
            pin_id = url.split("/pin/")[1].split("/")[0]
            return {"type": "pin", "id": pin_id}
        elif "/board/" in url:
            parts = url.split("/board/")[1].split("/")
            return {"type": "board", "username": parts[0], "board_name": parts[1]}
        else:
            raise ValueError("Unsupported Pinterest URL")

    async def _get_pin_data(self, pin_id: str) -> Dict:
        """Extract pin data and all associated images"""
        urls_to_try = [
            f"https://www.pinterest.com/pin/{pin_id}/",
            f"https://pinterest.com/pin/{pin_id}/"
        ]
        
        for url in urls_to_try:
            try:
                async with aiohttp.ClientSession(headers=self.headers) as session:
                    async with session.get(url) as response:
                        if response.status != 200:
                            continue
                        
                        html = await response.text()
                        soup = BeautifulSoup(html, 'html.parser')
                        
                        pin_data = {
                            'title': '',
                            'description': '',
                            'images': []
                        }

                        meta_title = soup.find('meta', property='og:title')
                        meta_desc = soup.find('meta', property='og:description')
                        pin_data['title'] = meta_title.get('content', '') if meta_title else ''
                        pin_data['description'] = meta_desc.get('content', '') if meta_desc else ''

                        for script in soup.find_all('script', type='application/json'):
                            try:
                                data = json.loads(script.string)
                                if 'props' in data and 'initialReduxState' in data['props']:
                                    pins = data['props']['initialReduxState'].get('pins', {})
                                    if pin_id in pins:
                                        json_images = self._extract_images_from_json(pins[pin_id])
                                        if json_images:
                                            pin_data['images'].extend(json_images)
                            except json.JSONDecodeError:
                                continue

                        if not pin_data['images']:
                            html_images = self._extract_images_from_html(soup)
                            pin_data['images'].extend(html_images)

                        if pin_data['images']:
                            return pin_data

            except Exception as e:
                logger.error(f"Error fetching from {url}: {str(e)}")
                continue

        raise Exception("Pin data not found")

    async def _download_file(self, url: str, filename: str) -> bool:
        """Download a file asynchronously"""
        try:
            async with aiohttp.ClientSession(headers=self.headers) as session:
                async with session.get(url) as response:
                    if response.status == 200:
                        filepath = self.download_path / filename
                        async with aiofiles.open(filepath, 'wb') as f:
                            await f.write(await response.read())
                        return True
            return False
        except Exception as e:
            logger.error(f"Error downloading file: {str(e)}")
            return False

    async def download_pin(self, url: str) -> Dict:
        """Download all images from a Pinterest pin"""
        try:
            parsed = await self._parse_url(url)
            if parsed["type"] != "pin":
                raise ValueError("URL must be a Pinterest pin")

            pin_data = await self._get_pin_data(parsed["id"])
            
            if not pin_data['images']:
                raise Exception("No images found in pin")

            unique_images = []
            seen_urls = set()
            for image in pin_data['images']:
                url = image['url']
                base_url = re.sub(r'/\d+x/', '/736x/', url)
                if base_url not in seen_urls:
                    seen_urls.add(base_url)
                    image['url'] = base_url
                    unique_images.append(image)

            downloaded_files = []
            for idx, image in enumerate(unique_images):
                try:
                    image_url = image['url']
                    suffix = Path(urlparse(image_url).path).suffix or '.jpg'
                    filename = f"pin_{parsed['id']}_{idx+1}{suffix}"
                    
                    success = await self._download_file(image_url, filename)
                    if success:
                        downloaded_files.append(str(self.download_path / filename))
                except Exception as e:
                    logger.error(f"Error downloading image {idx+1}: {str(e)}")

            if not downloaded_files:
                raise Exception("Failed to download any images")

            return {
                'success': True,
                'id': parsed["id"],
                'title': pin_data.get('title', ''),
                'description': pin_data.get('description', ''),
                'paths': downloaded_files,
                'timestamp': datetime.now().isoformat()
            }

        except Exception as e:
            logger.error(f"Error downloading pin: {str(e)}")
            return {
                'success': False,
                'error': str(e),
                'timestamp': datetime.now().isoformat()
            }
            
    async def download_board(self, url: str, limit: Optional[int] = None) -> List[Dict]:
        """Download all pins from a Pinterest board"""
        try:
            parsed = await self._parse_url(url)
            if parsed["type"] != "board":
                raise ValueError("URL must be a Pinterest board")

            pin_ids = await self._get_board_pins(parsed["username"], parsed["board_name"])

            if limit:
                pin_ids = pin_ids[:limit]

            results = []
            for pin_id in pin_ids:
                pin_url = f"https://www.pinterest.com/pin/{pin_id}/"
                result = await self.download_pin(pin_url)
                results.append(result)
                await asyncio.sleep(1)  # Rate limiting

            return results

        except Exception as e:
            logger.error(f"Error downloading board: {str(e)}")
            return [{
                'success': False,
                'error': str(e),
                'timestamp': datetime.now().isoformat()
            }]

    async def _get_board_pins(self, username: str, board_name: str) -> List[str]:
        """Get all pin IDs from a board"""
        board_url = f"https://www.pinterest.com/{username}/{board_name}/"
        pin_ids = []

        try:
            async with aiohttp.ClientSession(headers=self.headers) as session:
                async with session.get(board_url) as response:
                    if response.status != 200:
                        raise Exception(f"Failed to fetch board data. Status: {response.status}")
                    
                    html = await response.text()
                    soup = BeautifulSoup(html, 'html.parser')
                    
                    for script in soup.find_all('script', type='application/json'):
                        try:
                            data = json.loads(script.string)
                            if 'props' in data and 'initialReduxState' in data['props']:
                                board_data = data['props']['initialReduxState']
                                if 'pins' in board_data:
                                    pin_ids.extend(board_data['pins'].keys())
                        except json.JSONDecodeError:
                            continue
                    
                    if not pin_ids:
                        for element in soup.find_all(['div', 'a']):
                            pin_id = None
                            data_id = element.get('data-test-id', '')
                            href = element.get('href', '')
                            
                            if 'pin' in data_id:
                                pin_id = data_id.replace('pin', '')
                            elif '/pin/' in href:
                                pin_id = href.split('/pin/')[1].split('/')[0]
                            
                            if pin_id and pin_id.isdigit():
                                pin_ids.append(pin_id)

            return list(set(pin_ids))

        except Exception as e:
            logger.error(f"Error fetching board data: {str(e)}")
            raise Exception(f"Error fetching board data: {str(e)}")

pinterest_downloader = PinterestDownloader()

@Mbot.on_message(
    filters.incoming & 
    (
        filters.regex(r'https?://(?:www\.)?pinterest\.(?:com|it)/pin/[^\s]+') |
        filters.regex(r'https?://pin\.it/[^\s]+')
    ) & 
    (filters.private | filters.chat(AUTH_CHATS)))
@premium_required()
async def handle_pinterest_links(client: Client, message: Message):
    user_lang = get_user_language(message.from_user.id)
    lang_responses = PINTEREST_RESPONSES.get(user_lang, PINTEREST_RESPONSES["en"])
    lang_strings = PINTEREST_STRINGS.get(user_lang, PINTEREST_STRINGS["en"])
    # Check maintenance mode
    if is_maintenance_mode() and message.from_user.id not in SUDO_USERS:
        await message.reply_text(PINTEREST_RESPONSES.get(user_lang, {}).get("maintenance","ЁЯФз The bot is under maintenance. Please try again later."))
        return

    # Check Banned Users
    if message.from_user.id in banned_users:
        await message.reply_text(PINTEREST_RESPONSES.get(user_lang, {}).get("banned","You are banned from using this bot  р┤жр╡Нр┤жр┤┐ р╝Ор║╢тА┐р╝Ор║╢ ) "))
        return

    url = message.text
    msg = await message.reply_text(lang_responses["processing"])
    
    try:
        result = await pinterest_downloader.download_pin(url)
        
        if not result['success']:
            await msg.edit(f"тЭМ Error downloading from Pinterest: {result['error']}")
            return

        for file_path in result['paths']:
            try:
                if file_path.lower().endswith(('.png', '.jpg', '.jpeg', '.webp')):
                    await message.reply_photo(
                        file_path,
                        caption=lang_responses["media_caption"].format(
                            title=result.get('title', lang_strings["pin"]),
                            description=result.get('description', '')
                        )[:1024],
                        reply_to_message_id=message.id
                    )
                elif file_path.lower().endswith(('.mp4', '.mov', '.gif')):
                    await message.reply_video(
                        file_path,
                        caption=lang_responses["video_caption"].format(
                            title=result.get('title', lang_strings["pin"]),
                            description=result.get('description', '')
                        )[:1024],
                        reply_to_message_id=message.id
                    )
                os.remove(file_path)
            except Exception as e:
                logger.error(f"Error sending Pinterest content: {str(e)}")
                if os.path.exists(file_path):
                    os.remove(file_path)

        await msg.delete()

    except Exception as e:
        await msg.edit(lang_responses["error"].format(error=str(e)))

@Mbot.on_message(
    filters.incoming & 
    filters.regex(r'https?://(?:www\.)?pinterest\.(?:com|it)/[^/]+/[^/\s]+') & 
    (filters.private | filters.chat(AUTH_CHATS)))
@premium_required()
async def handle_pinterest_boards(client: Client, message: Message):
    user_lang = get_user_language(message.from_user.id)
    lang_responses = PINTEREST_RESPONSES.get(user_lang, PINTEREST_RESPONSES["en"])
    lang_strings = PINTEREST_STRINGS.get(user_lang, PINTEREST_STRINGS["en"])

    # Check maintenance mode
    if is_maintenance_mode() and message.from_user.id not in SUDO_USERS:
        await message.reply_text(PINTEREST_RESPONSES.get(user_lang, {}).get("maintenance","ЁЯФз The bot is under maintenance. Please try again later."))
        return

    # Check Banned Users
    if message.from_user.id in banned_users:
        await message.reply_text(PINTEREST_RESPONSES.get(user_lang, {}).get("banned","You are banned from using this bot  р┤жр╡Нр┤жр┤┐ р╝Ор║╢тА┐р╝Ор║╢ ) "))
        return

    url = message.text
    msg = await message.reply_text(lang_responses["processing_board"])
    
    try:
        parsed = urlparse(url)
        path_parts = [p for p in parsed.path.split('/') if p]
        
        if len(path_parts) < 2:
            await msg.edit(lang_responses["invalid_url"])
            return
            
        results = await pinterest_downloader.download_board(url, limit=5)
        
        success_count = sum(1 for r in results if r['success'])
        if success_count == 0:
            await msg.edit(lang_responses["error"].format(error=error))
            return

        await msg.edit(lang_responses["board_success"].format(count=success_count))

    except Exception as e:
        await msg.edit(lang_responses["error"].format(error=str(e)))